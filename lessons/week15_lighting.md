# (15 неделя) - OpenGL 3.0: Освещение

Распространение света в реальном мире это чрезвычайно сложное явление, зависящее от слишком многих факторов. Поэтому освещение в OpenGL основано на использовании приближенных к реальности упрощенных математических моделей, которые выглядят достаточно похожими, но рассчитываются гораздо проще. Эти модели освещения описывают физику света исходя из нашего понимания его природы. Одна из этих моделей называется **моделью освещения по Фонгу** (Phong). Модель Фонга состоит из трех главных компонентов: **фонового** (ambient), **рассеянного/диффузного** (diffuse) и **бликового** (specular). 

#### Фоновое освещение

Даже в самой темной сцене обычно всегда есть хоть какой-нибудь свет (луна, дальний свет), поэтому объекты почти никогда не бывают абсолютно чёрными. Чтобы имитировать это, мы используем константу окружающего освещения, которая всегда будет придавать объекту некоторый оттенок.

Добавить фоновое освещение в сцену очень просто. Для этого нужно взять цвет источника света, умножить его на небольшой константный коэффициент фонового освещения, затем умножить полученное значение на цвет объекта и использовать вычисленную величину как цвет фрагмента. Для этого добавьте следующие фрагменты кода во фрагментный шейдер:

```
void main()\
	{\
		vec3 lightColor = vec3(1,1,0);\
		vec3 objectColor = vec3(1,1,1);\
		float amb = 1.0f;\
		gl_FragColor = vec4(lightColor * amb  * objectColor, 1);\
	}";
```

Константный коэффициент фонового освещения (amb) можно регулировать, например на следующих рисунках коэффициенты равны (0.1f, 0.5f, 1/0f) соответственно.

<img src="https://github.com/aktumar/Learning_Computer_Graphics/blob/master/lessons/images/lighting_ambient=0.1.png" width="200" height="200"/>   <img src="https://github.com/aktumar/Learning_Computer_Graphics/blob/master/lessons/images/lighting_ambient=0.5.png" width="200" height="200"/>   <img src="https://github.com/aktumar/Learning_Computer_Graphics/blob/master/lessons/images/lighting_ambient=1.0.png" width="200" height="200"/>

#### Диффузное освещение

Диффузное освещение имитирует воздействие на объект направленного источника света. Это наиболее визуально значимый компонент модели освещения. Чем большая часть поверхности объекта обращена к источнику света, тем ярче он будет освещен.

Диффузное освещение оказывает на внешний вид объекта весьма значительное визуальное воздействие. Чем более перпендикулярно направлению лучей источника света расположены фрагменты объекта, тем большую яркость им придает диффузная составляющая освещения.

![img](https://github.com/aktumar/Learning_Computer_Graphics/blob/master/lessons/images/lighting_diffusion.png)

Слева мы видим исходящий от источника света луч, направленный на некоторый фрагмент нашего объекта. Нам нужно измерить угол падения луча на фрагмент. Воздействие света источника на цвет фрагмента становится максимальным при перпендикулярном направлении луча к поверхности объекта. 

Для измерения угла между лучом света и фрагментом мы воспользуемся так называемым **вектором нормали**, который является перпендикуляром к поверхности фрагмента (вектор нормали изображен в виде желтой стрелки). Тогда угол между двумя векторами можно легко вычислить с помощью скалярного произведения. чем меньше угол между двумя единичными векторами, тем больше результат скалярного произведения стремится к значению 1.0. Когда угол между обоими векторами составляет 90 градусов, скалярное произведение этих векторов становится равным 0.

К предыдущему коду добавьте следующие фрагменты:

```
GLuint nbo;
GLuint normalLoc;
```

Вершинный шейдер:

```
		attribute vec3 normal1;\
        varying vec3 normal2;\
        normal2 = normal1;\n\
```

Фрагментный шейдер:

```
		varying vec3 normal2;\
```

Буфер, массив:

	float normals[] = {
	
	 0.0f,  0.0f, -1.0f,
	 0.0f,  0.0f, -1.0f,
	 0.0f,  0.0f, -1.0f,
	 0.0f,  0.0f, -1.0f,
	 0.0f,  0.0f, -1.0f,
	 0.0f,  0.0f, -1.0f,
	
	 0.0f,  0.0f,  1.0f,
	 0.0f,  0.0f,  1.0f,
	 0.0f,  0.0f,  1.0f,
	 0.0f,  0.0f,  1.0f,
	 0.0f,  0.0f,  1.0f,
	 0.0f,  0.0f,  1.0f,
	
	-1.0f,  0.0f,  0.0f,
	-1.0f,  0.0f,  0.0f,
	-1.0f,  0.0f,  0.0f,
	-1.0f,  0.0f,  0.0f,
	-1.0f,  0.0f,  0.0f,
	-1.0f,  0.0f,  0.0f,
	
	 1.0f,  0.0f,  0.0f,
	 1.0f,  0.0f,  0.0f,
	 1.0f,  0.0f,  0.0f,
	 1.0f,  0.0f,  0.0f,
	 1.0f,  0.0f,  0.0f,
	 1.0f,  0.0f,  0.0f,
	
	 0.0f, -1.0f,  0.0f,
	 0.0f, -1.0f,  0.0f,
	 0.0f, -1.0f,  0.0f,
	 0.0f, -1.0f,  0.0f,
	 0.0f, -1.0f,  0.0f,
	 0.0f, -1.0f,  0.0f,
	
	 0.0f,  1.0f,  0.0f,
	 0.0f,  1.0f,  0.0f,
	 0.0f,  1.0f,  0.0f,
	 0.0f,  1.0f,  0.0f,
	 0.0f,  1.0f,  0.0f,
	 0.0f,  1.0f,  0.0f,
	};
	
	glGenBuffers(1, &nbo);
	glBindBuffer(GL_ARRAY_BUFFER, nbo);
	glBufferData(GL_ARRAY_BUFFER, 108 * sizeof(float), normals, GL_STATIC_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
Связь

```
	normalLoc = glGetAttribLocation(program, "normal2");
```

Затем возвращаемся к шейдерам, на этом этапе у вас должен отображаться предыдущий куб.

Теперь у нас для каждой вершины есть вектор нормали, но нам по-прежнему нужны вектора с координатами источника света и фрагмента. Так как позиция источника света задана одной не изменяющейся переменной, то мы просто объявим её во фрагментном шейдере как uniform-переменную:

```
uniform vec3 lightPosition;\

----> lightPos = glGetUniformLocation(program, "lightPosition");

-------> glUniform3f(lightPos, -0.6, 0.6, 0.6);

```

Последнее, что потребуется, это позиция текущего фрагмента. Мы собираемся производить все расчеты освещения в мировом пространстве координат, поэтому и позиции вершин нам будут нужны нужна в мировых координатах. Преобразование позиции вершины в мировые координаты достигается умножением её атрибута позиции только на матрицу преобразования. Это легко может быть выполнено в вершинном шейдере, поэтому давайте объявим в нем выходную переменную и вычислим координаты вершины в мировом пространстве:

```
		attribute vec3 pos1;\n\
		attribute vec3 normal1;\
		varying vec3 pos2;\
		varying vec3 normal2;\
	void main()\n\
	{\n\
		gl_Position = cam * view * vec4(pos1, 1); \n\
	
		pos2 = vec3(cam * view * vec4(pos1, 1));\
		normal2 = normal1;\n\
	}";
```

И, наконец, добавьте соответствующую varying переменную во фрагментный шейдер:

```
		varying vec3 normal2;\
		varying vec3 pos2;\
```

Теперь, когда все необходимые переменные установлены, мы можем начать во фрагментном шейдере расчеты освещения.

Первое, что нам нужно вычислить, это вектор направления между источником света и фрагментом. 

```
	void main()\n\
	{\n\
		vec3 lightColor = vec3(1,1, 1);\
		vec3 objectColor = vec3(0,0, 1);\
		\
		float amb = 0.6f;\n\
		\
		float diff = max(dot(normal2, lightPosition - pos2), 0.0);\
		gl_FragColor = vec4(amb * diff * lightColor * objectColor, 1); \n\
	}";
```

Дальше, посредством скалярного произведения векторов **normal2** и **lightPosition - pos2**, нам нужно вычислить величину воздействия диффузного освещения на текущий фрагмент. Затем, это значение умножается на цвет источника света, и в результате мы получим компоненту диффузного освещения, которая будет становиться темнее с ростом угла между векторами:

Если угол между векторами больше 90 градусов, то результат скалярного произведения будет отрицательным, и мы получим отрицательную составляющую диффузного света. По этой причине мы используем функцию **max**, которая возвращает наибольший из переданных ей параметров, и гарантирует, что диффузная компонента света (и, следовательно, цвета) никогда не будут меньше 0.0. Моделей освещения для отрицательных значений цвета не существует.

Теперь, когда у нас есть фоновый и диффузный компоненты, мы суммируем их цвета, а затем умножаем результат на цвет объекта, получая таким образом результирующий цвет выходного фрагмента:

В качестве результата у вас должно получиться следующее:

<img src="https://github.com/aktumar/Learning_Computer_Graphics/blob/master/lessons/images/lighting_diffusion=0.3.png" width="200" height="200"/>   <img src="https://github.com/aktumar/Learning_Computer_Graphics/blob/master/lessons/images/lighting_diffusion=0.6.png" width="200" height="200"/>   <img src="https://github.com/aktumar/Learning_Computer_Graphics/blob/master/lessons/images/lighting_diffusion=0.9.png" width="200" height="200"/>

#### Освещение зеркальных бликов

Освещение зеркальных бликов имитирует яркое пятно света (блик), которое появляется на блестящих объектах. По цвету зеркальные блики часто ближе к цвету источника света, чем к цвету объекта.

Освещение зеркальных бликов, так же как и рассеянное освещение, основано на векторе направления источника света и нормали поверхности объекта, но кроме этого в вычислениях учитывается и позиция наблюдателя, то есть направление, в котором игрок смотрит на фрагмент. Зеркальное освещение основано на отражательных свойствах света. Если представить поверхность объекта в виде зеркала, то освещение бликов будет наибольшим в том месте, где бы мы увидели отраженный от поверхности свет источника. Этот эффект показан на следующем изображении:

![img](https://github.com/aktumar/Learning_Computer_Graphics/blob/master/lessons/images/lighting_specular.png)

Вектор отражения вычисляется путем отражения направления света относительно вектора нормали. Затем мы вычисляем угловое расстояние между этим вектором отражения и направлением взгляда; чем меньше угол между ними, тем большее воздействие на цвет фрагмента оказывает освещение зеркальных бликов. В результате этого эффекта, когда мы смотрим в направлении источника света, то видим на поверхности объекта отраженный блик.

Вектор просмотра — это еще одна дополнительная переменная, необходимая для рассчета освещения зеркальных бликов. Мы можем её вычислить используя мировые координаты точки зрения наблюдателя и положения фрагмента. Затем мы вычисляем интенсивность блика, умножаем ее на цвет освещения и добавляем к вычисленным ранее компонентам фонового и рассеянного освещения.

Чтобы получить координаты наблюдателя в мировом пространстве, мы просто берем вектор положения объекта камеры. Так что необходимо добавить еще одну uniform-переменную в шейдер фрагментов и передать в него соответствующий вектор положения камеры:

```
	glUniform3f(viewLightPos, 1.5, 1.5, 1.5);
```

Теперь, когда у нас есть все необходимые переменные, мы можем вычислить интенсивность блика. Для начала мы зададим зеркальному блику среднее значение интенсивности, чтобы он не оказывал слишком сильного воздействия:

```
float specularStrength = 0.5f;
```

Вычислим вектор направления взгляда и соответствующий ему вектор отражения относительно оси, которой является нормаль:

```
		vec3 viewDir = normalize(viewPosition - pos2);\
		vec3 reflectDir = reflect(-lightDir, normal2);\
```

Обратите внимание, что мы инвертировали вектор **lightDir**. Функция **reflect** ожидает, что первый вектор будет указывать направление **от** источника света к положению фрагмента, но вектор **lightDir** в настоящее время указывает в обратную сторону, то есть от фрагмента **к** источнику света (направление зависит от порядка вычитания векторов, которое мы делали при вычислении вектора **lightDir**). Поэтому, для получения правильного вектора отражения, мы меняем его направление на противоположное посредством инверсии вектора **lightDir**. Предполагается, что второй аргумент должен быть единичной длинны, и мы передаем нормализованный вектор **normal2**.

Остается только вычислить компонент зеркального блика. Это выполняется по следующей формуле:

```
		float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);\
		vec3 specular = specularStrength * spec * lightColor;\
```

Сначала вычисляется скалярное произведение векторов отражения и направления взгляда (с отсевом отрицательных значений), а затем результат возводится в 32-ю степень. Константное значение 32 задает силу блеска. Чем больше это значение, тем сильнее свет будет отражаться, а не рассеиваться, и тем меньше станет размер пятна блика.

Мы не хотим, чтобы компонент зеркальных бликов слишком выделялся, поэтому оставим показатель степени равным 32. Остается только сложить полученную величину вместе с компонентами фонового и рассеянного освещения, после чего умножить результат на цвет объекта:

```
		vec3 result = (amb + diff + specular) * objectColor;\
		gl_FragColor = vec4(result, 1); \n\
```

В качестве результата вы должны увидеть следующую картину:

![img](https://github.com/aktumar/Learning_Computer_Graphics/blob/master/lessons/images/lighting_specular_ref=1.png)







#### КОД ИЗ ЛЕКЦИИ:

**Код для фонового освещения:**

```
GLuint nbo;
GLuint normalLoc;

/*******************************************************************************/

	const char* vshCode = "#version 120\n\
          uniform mat4 cam;\n\
          uniform mat4 view;\n\
		attribute vec3 pos1;\n\
		attribute vec3 normal1;\
		varying vec3 pos2;\
		varying vec3 normal2;\
		void main()\n\
	{\n\
		gl_Position = cam * view * vec4(pos1, 1); \n\
		pos2 = vec3(cam * view * vec4(pos1, 1));\
		normal2 = normal1;\n\
	}";

/*******************************************************************************/

	const char* fshCode = "#version 120\n\
		varying vec3 normal2;\
		varying vec3 pos2;\
		void main()\n\
	{\n\
		vec3 lightColor = vec3(1,1, 1);\
		vec3 objectColor = vec3(0,1, 0);\
		\
		float amb = 0.1f;\n\
		\
		vec3 result = lightColor * (amb) * objectColor;\
		gl_FragColor = vec4(result, 1); \n\
	}";

/*******************************************************************************/

	normalLoc = glGetAttribLocation(program, "normal2");
		posLoc = glGetAttribLocation(program, "pos1");

/*******************************************************************************/
	float normals[] = {

	 0.0f,  0.0f, -1.0f,
	 0.0f,  0.0f, -1.0f,
	 0.0f,  0.0f, -1.0f,
	 0.0f,  0.0f, -1.0f,
	 0.0f,  0.0f, -1.0f,
	 0.0f,  0.0f, -1.0f,

	 0.0f,  0.0f,  1.0f,
	 0.0f,  0.0f,  1.0f,
	 0.0f,  0.0f,  1.0f,
	 0.0f,  0.0f,  1.0f,
	 0.0f,  0.0f,  1.0f,
	 0.0f,  0.0f,  1.0f,

	-1.0f,  0.0f,  0.0f,
	-1.0f,  0.0f,  0.0f,
	-1.0f,  0.0f,  0.0f,
	-1.0f,  0.0f,  0.0f,
	-1.0f,  0.0f,  0.0f,
	-1.0f,  0.0f,  0.0f,

	 1.0f,  0.0f,  0.0f,
	 1.0f,  0.0f,  0.0f,
	 1.0f,  0.0f,  0.0f,
	 1.0f,  0.0f,  0.0f,
	 1.0f,  0.0f,  0.0f,
	 1.0f,  0.0f,  0.0f,

	 0.0f, -1.0f,  0.0f,
	 0.0f, -1.0f,  0.0f,
	 0.0f, -1.0f,  0.0f,
	 0.0f, -1.0f,  0.0f,
	 0.0f, -1.0f,  0.0f,
	 0.0f, -1.0f,  0.0f,

	 0.0f,  1.0f,  0.0f,
	 0.0f,  1.0f,  0.0f,
	 0.0f,  1.0f,  0.0f,
	 0.0f,  1.0f,  0.0f,
	 0.0f,  1.0f,  0.0f,
	 0.0f,  1.0f,  0.0f,
	};

	glGenBuffers(1, &nbo);
	glBindBuffer(GL_ARRAY_BUFFER, nbo);
	glBufferData(GL_ARRAY_BUFFER, 108 * sizeof(float), normals, GL_STATIC_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, 0);

/*******************************************************************************/

	glEnableVertexAttribArray(posLoc);
	glEnableVertexAttribArray(normalLoc);

	glBindBuffer(GL_ARRAY_BUFFER, vbo);
	glVertexAttribPointer(posLoc, 3, GL_FLOAT, GL_FALSE, 0, 0);

	glBindBuffer(GL_ARRAY_BUFFER, nbo);
	glVertexAttribPointer(normalLoc, 3, GL_FLOAT, GL_FALSE, 0, 0);

	glDrawArrays(GL_TRIANGLES, 0, 36);

	glDisableVertexAttribArray(posLoc);
	glDisableVertexAttribArray(normalLoc);
	
```

**Код для диффузного освещения:**

```
	GLuint lightPos;
	/*******************************************************************************/
		const char* vshCode = "#version 120\n\
          uniform mat4 cam;\n\
          uniform mat4 view;\n\
		attribute vec3 pos1;\n\
		attribute vec3 normal1;\
		varying vec3 pos2;\
		varying vec3 normal2;\
		void main()\n\
	{\n\
		gl_Position = cam * view * vec4(pos1, 1); \n\
		pos2 = vec3(cam * view * vec4(pos1, 1));\
		normal2 = normal1;\n\
	}";
	/*******************************************************************************/

const char* fshCode = "#version 120\n\
		varying vec3 normal2;\
		varying vec3 pos2;\
		uniform vec3 lightPosition;\
		void main()\n\
	{\n\
		vec3 lightColor = vec3(1,1, 1);\
		vec3 objectColor = vec3(0,1, 0);\
		\
		float amb = 0.1f;\n\
		\
		\
		vec3 lightDir = normalize(lightPosition - pos2);\
		float diff = max(dot(normal2, lightDir), 0.0);\
		\
		vec3 result = (amb + diff) * objectColor;\
		gl_FragColor = vec4(result, 1); \n\
	}";
	
	/*******************************************************************************/
	
		lightPos = glGetUniformLocation(program, "lightPosition");
	/*******************************************************************************/
		glUniform3f(lightPos, -1.6, 1.6, 1.6);
```

**Код для бликов:**

```
	GLuint viewLightPos;
	
/*******************************************************************************/	
	GLuint vsh = glCreateShader(GL_VERTEX_SHADER);
	const char* vshCode = "#version 120\n\
          uniform mat4 cam;\n\
          uniform mat4 view;\n\
		attribute vec3 pos1;\n\
		attribute vec3 normal1;\
		varying vec3 pos2;\
		varying vec3 normal2;\
		void main()\n\
	{\n\
		gl_Position = cam * view * vec4(pos1, 1); \n\
		pos2 = vec3(cam * view * vec4(pos1, 1));\
		normal2 = normal1;\n\
	}";

/*******************************************************************************/

GLuint fsh = glCreateShader(GL_FRAGMENT_SHADER);
	const char* fshCode = "#version 120\n\
		varying vec3 normal2;\
		varying vec3 pos2;\
		uniform vec3 lightPosition;\
		uniform vec3 viewPosition;\
		void main()\n\
	{\n\
		vec3 lightColor = vec3(1,1, 1);\
		vec3 objectColor = vec3(0,1, 0);\
		\
		float amb = 0.1f;\n\
		\
		float specularStrength = 1.0f;\
		\
		vec3 lightDir = normalize(lightPosition - pos2);\
		float diff = max(dot(normal2, lightDir), 0.0);\
		\
		vec3 viewDir = normalize(viewPosition - pos2);\
		vec3 reflectDir = reflect(-lightDir, normal2);\
		float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);\
		vec3 specular = specularStrength * spec * lightColor;\
		\
		vec3 result = (amb + diff + specular) * objectColor;\
		gl_FragColor = vec4(result, 1); \n\
	}";
/*******************************************************************************/

viewLightPos = glGetUniformLocation(program, "viewPosition");
/*******************************************************************************/

glUniform3f(viewLightPos, 1.5, 1.5, 1.5);
		
```



# Источники

[1] learnopengl. Урок 2.2 — Основы освещения - https://habr.com/ru/post/333932/